import { IProvider, IProviderCapabilities, IProviderHealth, IProviderUsage, ProviderConfig, ProviderType } from '@agent-flow/agents';

/**
 * Mock provider implementation for testing and development
 * This provider simulates AI responses without making actual API calls
 */
export class MockProvider implements IProvider {
  public readonly id: string;
  public readonly type: ProviderType;
  public readonly config: ProviderConfig;
  public readonly capabilities: IProviderCapabilities;
  
  private isInitialized = false;
  private requestCount = 0;
  private totalTokens = 0;

  constructor(id = 'mock-provider') {
    this.id = id;
    this.type = ProviderType.OPENAI; // Mock as OpenAI for compatibility
    this.config = {
      type: ProviderType.OPENAI,
      model: 'gpt-4',
      maxTokens: 4000,
      temperature: 0.7
    };
    this.capabilities = {
      supportsStreaming: true,
      supportsToolCalling: false,
      supportsVision: false,
      supportsCodeExecution: false,
      maxContextLength: 8000,
      supportedFormats: ['text']
    };
  }

  /**
   * Initialize the mock provider
   */
  async initialize(): Promise<void> {
    if (this.isInitialized) {
      return;
    }
    
    // Simulate initialization delay
    await new Promise(resolve => setTimeout(resolve, 100));
    this.isInitialized = true;
    console.log(`Mock provider ${this.id} initialized successfully`);
  }

  /**
   * Generate a mock response
   */
  async generate(prompt: string, options?: Record<string, any>): Promise<string> {
    if (!this.isInitialized) {
      throw new Error('Provider not initialized');
    }

    this.requestCount++;
    const responseTokens = Math.floor(Math.random() * 500) + 100;
    this.totalTokens += responseTokens;

    // Simulate processing delay
    await new Promise(resolve => setTimeout(resolve, 200 + Math.random() * 300));

    // Generate a mock response based on the prompt
    const responses = [
      `I understand you need help with: "${prompt.substring(0, 50)}...". Here's my analysis and recommendations.`,
      `Based on your request about "${prompt.substring(0, 50)}...", I can provide the following insights.`,
      `Thank you for your query regarding "${prompt.substring(0, 50)}...". Let me break this down for you.`,
      `I've analyzed your request about "${prompt.substring(0, 50)}..." and here's what I recommend.`
    ];

    const randomResponse = responses[Math.floor(Math.random() * responses.length)];
    return `${randomResponse}\n\n[This is a mock response from ${this.id}. In a real implementation, this would be generated by an AI model.]`;
  }

  /**
   * Stream a mock response
   */
  async* stream(prompt: string, options?: Record<string, any>): AsyncIterable<string> {
    if (!this.isInitialized) {
      throw new Error('Provider not initialized');
    }

    const response = await this.generate(prompt, options);
    const words = response.split(' ');
    
    for (const word of words) {
      yield word + ' ';
      await new Promise(resolve => setTimeout(resolve, 50));
    }
  }

  /**
   * Check provider health
   */
  async healthCheck(): Promise<IProviderHealth> {
    const latency = Math.floor(Math.random() * 100) + 50;
    
    return {
      providerId: this.id,
      isHealthy: this.isInitialized,
      latency,
      lastCheck: new Date(),
      errorMessage: this.isInitialized ? undefined : 'Provider not initialized'
    };
  }

  /**
   * Get usage statistics
   */
  async getUsage(): Promise<IProviderUsage> {
    return {
      providerId: this.id,
      totalRequests: this.requestCount,
      totalTokens: this.totalTokens,
      inputTokens: Math.floor(this.totalTokens * 0.3),
      outputTokens: Math.floor(this.totalTokens * 0.7),
      totalCost: this.totalTokens * 0.0001, // Mock cost calculation
      averageResponseTime: 250,
      errorRate: 0.01,
      lastUsed: new Date()
    };
  }

  /**
   * Cleanup provider resources
   */
  async cleanup(): Promise<void> {
    this.isInitialized = false;
    console.log(`Mock provider ${this.id} cleaned up`);
  }
}